# JVM 不同 GC 的总结



## SerialGC

单线程，主要工作原理，在 JVM 需要 GC 时，暂停所有的工作线程，对新生代进行`复制` GC 清除，对老年代进行 `标记-整理` 清除。

- 优点：简单高效，适合单核CPU，Client 模式下的程序
- 缺点：Stop the world明显，不适合服务器使用。



## ParallelGC

这个收集器的目标，是达到一个可控制的吞吐量。**所谓吞吐量，就是 CPU 运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码的时间/(运行用户代码时间 + 垃圾收集器时间)，eg: 虚拟机一共运行100分钟，其中垃圾收集划掉1分钟，那吞吐量就是99%**



## CMS GC（ConcMarkSweepGC）

是一种以获取最短回收停顿时间为目标的收集器。关注服务端的响应速度，希望系统停顿时间短，CMS 收集器会非常符合这类应用。过程分4个步骤

- 初始标记(CMS inital mark)
- 并发标记(CMS concurrent mark)
- 重新标记(CMS remark)
- 并发清除(CMS concurrent sweep)

以下有几个特点：

- 初始标记、重新标记都是需要Stop the world，不过时间都比较短。
- 并发标记和并发清除是消耗时间最长的，并且会和用户线程一起进行。
- 并发标记就是从 CG Root 进行 Tracing 的过程，重新标记阶段是为了修正并发标记期间，用户程序继续运作导致标记产生变动的那一部分对象的标记记录。 优点：
- 正在的 GC 线程和用户线程共同执行，Stop the world 比较低，。

缺点：

- CPU 资源敏感，会占用一部分的CPU资源导致用户线程停顿，总吞吐量会下降。一般比较适合多核CPU主机；
- 无法处理浮动垃圾；
- 由于采取标记-清除算法，会存在空间碎片，可能需要引起 Full GC进行解决。



## G1 GC

是一个比较先进的收集器。

##### 堆结构

G1 会把一整块的堆空间，划分为固定内存的 region，大小从1-32Mb不等。

##### 内存分配

region 会被分为 Eden、Survivor和old，这只是一个标签。对 region 的回收是并行的，其他线程照常工作。

##### Young GC

存活的对象从eden被转移到一个或多个survivor区，年龄达到一定阈值，就上升到 old 区

##### 老年代GC

- 初始标记 (STW，原理和CMS的基本一致)
- 根分区扫描
- 并发标记(在这个堆中查找存活对象。这个阶段可能被YGC打断)
- 重新标记(STW，完成堆内存中存活对象的标记，使用一种SATB起始快照的算法)
- 清理阶段。

#### G1特点

- 并行和并发
- 分代收集
- 空间整合(标记-整理算法)
- 可预测的停顿(允许程序通过参数约定垃圾收集的时间)

#### G1适合那些机器

- 和CMS同理，对响应时间要求高，吞吐量要求不太严格的
- 多核CPU，大内存JVM应用，Oracle 表示 G1 适用于堆大小为6GB以上的服务器应用程序。

